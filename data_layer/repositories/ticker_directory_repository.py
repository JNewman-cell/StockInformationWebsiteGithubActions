"""
Ticker directory repository for database operations.
"""

import logging
import psycopg
from typing import List, Optional, Any

from .base_repository import BaseRepository
from ..models.ticker_directory import TickerDirectory, TickerDirectoryStatus
from ..database.connection_manager import DatabaseConnectionManager
from ..exceptions import DatabaseQueryError


class TickerDirectoryNotFoundError(Exception):
    """Exception raised when a ticker directory entry is not found."""
    
    def __init__(self, identifier: str, value: Any):
        self.identifier = identifier
        self.value = value
        super().__init__(f"Ticker directory entry not found by {identifier}: {value}")


class DuplicateTickerDirectoryError(Exception):
    """Exception raised when attempting to create a duplicate ticker directory entry."""
    
    def __init__(self, ticker: str):
        self.ticker = ticker
        super().__init__(f"Ticker directory entry already exists for ticker: {ticker}")


class TickerDirectoryRepository(BaseRepository[TickerDirectory]):
    """
    Repository for ticker directory entities with full CRUD operations.
    Organized by: CREATE, READ, UPDATE, DELETE operations.
    Supports searching by ID (primary key), ticker, and CIK with filtering by status.
    """
    
    def __init__(self, db_manager: DatabaseConnectionManager):
        """
        Initialize the ticker directory repository.
        
        Args:
            db_manager: Database connection manager instance
        """
        super().__init__(db_manager)
        self.logger = logging.getLogger(__name__)
        self.table_name = "ticker_directory"
    
    # ============================================================================
    # CREATE OPERATIONS
    # ============================================================================
    
    def insert(self, entity: TickerDirectory) -> TickerDirectory:
        """
        Create a new ticker directory entry in the database.
        Note: ID is auto-generated by the database.
        
        Args:
            entity: TickerDirectory entity to create
        
        Returns:
            Created ticker directory with generated ID
        
        Raises:
            DuplicateTickerDirectoryError: If ticker already exists
            DatabaseQueryError: If database operation fails
        """
        # Note: id is GENERATED ALWAYS AS IDENTITY, so we don't insert it
        insert_query = """
        INSERT INTO ticker_directory (ticker, cik, status)
        VALUES (%s, %s, %s)
        RETURNING cik, ticker, created_at, last_updated_at, status, id;
        """
        
        try:
            with self.db_manager.get_cursor_context() as cursor:
                cursor.execute(
                    insert_query,
                    (
                        entity.ticker,
                        entity.cik,
                        entity.status.value
                    )
                )
                row = cursor.fetchone()
                
                if row is None:
                    raise DatabaseQueryError("insert ticker directory", "No row returned after insert")
                
                created_entity = self._row_to_entity(row)
                self.logger.info(f"Successfully inserted ticker directory: ticker {created_entity.ticker}, ID {created_entity.id}")
                return created_entity

        except psycopg.errors.UniqueViolation:
            raise DuplicateTickerDirectoryError(entity.ticker)
        except Exception as e:
            raise DatabaseQueryError("insert ticker directory", str(e))
    
    def bulk_insert(self, entities: List[TickerDirectory]) -> int:
        """
        Insert multiple ticker directory entries in a single transaction.
        Skips entries that already exist (uses ON CONFLICT DO NOTHING on ticker).
        
        Args:
            entities: List of TickerDirectory entities to insert
        
        Returns:
            Number of rows successfully inserted
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        if not entities:
            return 0
        insert_query = """
        INSERT INTO ticker_directory (ticker, cik, status)
        VALUES (%s, %s, %s)
        ON CONFLICT (cik, ticker) DO NOTHING;
        """
        
        try:
            with self.db_manager.get_cursor_context() as cursor:
                data = [
                    (
                        td.ticker,
                        td.cik,
                        td.status.value
                    )
                    for td in entities
                ]
                cursor.executemany(insert_query, data)
                rows_inserted = cursor.rowcount
                self.logger.info(f"Successfully bulk inserted {rows_inserted} ticker directory entries")
                return rows_inserted

        except Exception as e:
            raise DatabaseQueryError("bulk insert ticker directory", str(e))
    
    # ============================================================================
    # READ OPERATIONS
    # ============================================================================
    
    def get_by_ticker(self, ticker: str) -> Optional[TickerDirectory]:
        """
        Retrieve a ticker directory entry by its ticker symbol.
        
        Args:
            ticker: The ticker symbol to retrieve
        
        Returns:
            TickerDirectory if found, None otherwise
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        select_query = """
        SELECT cik, ticker, created_at, last_updated_at, status, id
        FROM ticker_directory
        WHERE ticker = %s;
        """
        
        try:
            with self.db_manager.get_cursor_context(commit=False) as cursor:
                cursor.execute(select_query, (ticker.upper(),))
                row = cursor.fetchone()

                if row is None:
                    return None

                return self._row_to_entity(row)

        except Exception as e:
            raise DatabaseQueryError("get ticker directory by ticker", str(e))
    
    def get_by_cik(self, cik: int) -> Optional[TickerDirectory]:
        """
        Retrieve a ticker directory entry by its CIK.
        
        Args:
            cik: The CIK to retrieve
        
        Returns:
            TickerDirectory if found, None otherwise
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        select_query = """
        SELECT cik, ticker, created_at, last_updated_at, status, id
        FROM ticker_directory
        WHERE cik = %s;
        """
        
        try:
            with self.db_manager.get_cursor_context(commit=False) as cursor:
                cursor.execute(select_query, (cik,))
                row = cursor.fetchone()

                if row is None:
                    return None

                return self._row_to_entity(row)

        except Exception as e:
            raise DatabaseQueryError("get ticker directory by CIK", str(e))
    
    def get_by_ciks(self, ciks: List[int]) -> List[TickerDirectory]:
        """
        Retrieve ticker directory entries by multiple CIKs.
        
        Args:
            ciks: List of CIKs to retrieve
        
        Returns:
            List of TickerDirectory entries
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        if not ciks:
            return []
        
        select_query = """
        SELECT cik, ticker, created_at, last_updated_at, status, id
        FROM ticker_directory
        WHERE cik = ANY(%s);
        """
        
        try:
            with self.db_manager.get_cursor_context(commit=False) as cursor:
                cursor.execute(select_query, (ciks,))
                rows = cursor.fetchall()
                
                return [self._row_to_entity(row) for row in rows]

        except Exception as e:
            raise DatabaseQueryError("get ticker directory by CIKs", str(e))
    
    def get_by_status(self, status: TickerDirectoryStatus, 
                     limit: Optional[int] = None, 
                     offset: Optional[int] = None) -> List[TickerDirectory]:
        """
        Retrieve ticker directory entries by status.
        
        Args:
            status: The status to filter by
            limit: Maximum number of entries to return
            offset: Number of entries to skip
        
        Returns:
            List of TickerDirectory entries
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        query_parts = ["""
        SELECT cik, ticker, created_at, last_updated_at, status, id
        FROM ticker_directory
        WHERE status = %s
        ORDER BY id"""]
        
        params: List[Any] = [status.value]
        
        if limit is not None:
            query_parts.append(" LIMIT %s")
            params.append(limit)
        if offset is not None:
            query_parts.append(" OFFSET %s")
            params.append(offset)
        
        query = "".join(query_parts) + ";"
        
        try:
            with self.db_manager.get_cursor_context(commit=False) as cursor:
                cursor.execute(query, params)  # type: ignore[arg-type]
                rows = cursor.fetchall()

                return [self._row_to_entity(row) for row in rows]

        except Exception as e:
            raise DatabaseQueryError("get ticker directory by status", str(e))
    
    def get_all(self, limit: Optional[int] = None, offset: Optional[int] = None) -> List[TickerDirectory]:
        """
        Retrieve all ticker directory entries with optional pagination.
        
        Args:
            limit: Maximum number of entries to return
            offset: Number of entries to skip
        
        Returns:
            List of TickerDirectory entries
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        query_parts = ["""
        SELECT cik, ticker, created_at, last_updated_at, status, id
        FROM ticker_directory
        ORDER BY id"""]
        
        params: List[int] = []
        
        if limit is not None:
            query_parts.append(" LIMIT %s")
            params.append(limit)
        if offset is not None:
            query_parts.append(" OFFSET %s")
            params.append(offset)
        
        query = "".join(query_parts) + ";"
        
        try:
            with self.db_manager.get_cursor_context(commit=False) as cursor:
                cursor.execute(query, params)  # type: ignore[arg-type]
                rows = cursor.fetchall()

                return [self._row_to_entity(row) for row in rows]

        except Exception as e:
            raise DatabaseQueryError("get all ticker directory entries", str(e))
    
    def count(self) -> int:
        """
        Count the total number of ticker directory entries.
        
        Returns:
            Total count of entries
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        count_query = "SELECT COUNT(*) FROM ticker_directory;"
        
        try:
            with self.db_manager.get_cursor_context(commit=False) as cursor:
                cursor.execute(count_query)
                result = cursor.fetchone()
                return result[0] if result else 0

        except Exception as e:
            raise DatabaseQueryError("count ticker directory entries", str(e))
    
    def count_by_status(self, status: TickerDirectoryStatus) -> int:
        """
        Count ticker directory entries by status.
        
        Args:
            status: The status to filter by
        
        Returns:
            Count of entries with the given status
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        count_query = "SELECT COUNT(*) FROM ticker_directory WHERE status = %s;"
        
        try:
            with self.db_manager.get_cursor_context(commit=False) as cursor:
                cursor.execute(count_query, (status.value,))
                result = cursor.fetchone()
                return result[0] if result else 0

        except Exception as e:
            raise DatabaseQueryError("count ticker directory by status", str(e))
    
    def exists(self, ticker: str) -> bool:
        """
        Check if a ticker directory entry exists by ticker (primary key).
        
        Args:
            ticker: The ticker to check
        
        Returns:
            True if the entry exists, False otherwise
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        query = "SELECT 1 FROM ticker_directory WHERE ticker = %s LIMIT 1;"
        
        try:
            with self.db_manager.get_cursor_context(commit=False) as cursor:
                cursor.execute(query, (ticker.upper(),))
                return cursor.fetchone() is not None

        except Exception as e:
            raise DatabaseQueryError("check ticker directory existence", str(e))
    
    # ============================================================================
    # UPDATE OPERATIONS
    # ============================================================================
    
    def update(self, entity: TickerDirectory) -> TickerDirectory:
        """
        Update an existing ticker directory entry in the database.
        
        Args:
            entity: TickerDirectory entity to update (must have ticker)
        
        Returns:
            Updated TickerDirectory
        
        Raises:
            TickerDirectoryNotFoundError: If ticker doesn't exist
            DatabaseQueryError: If database operation fails
        """
        # Check if the entry exists
        existing = self.get_by_ticker(entity.ticker)
        if existing is None:
            raise TickerDirectoryNotFoundError("ticker", entity.ticker)
        
        update_query = """
        UPDATE ticker_directory
        SET cik = %s, status = %s, last_updated_at = CURRENT_TIMESTAMP
        WHERE ticker = %s
        RETURNING cik, ticker, created_at, last_updated_at, status, id;
        """
        
        try:
            with self.db_manager.get_cursor_context() as cursor:
                cursor.execute(
                    update_query,
                    (
                        entity.cik,
                        entity.status.value,
                        entity.ticker
                    )
                )
                row = cursor.fetchone()
                
                if row is None:
                    raise DatabaseQueryError("update ticker directory", "No row returned after update")
                
                updated_entity = self._row_to_entity(row)
                self.logger.info(f"Successfully updated ticker directory: ticker {entity.ticker}")
                return updated_entity

        except Exception as e:
            raise DatabaseQueryError("update ticker directory", str(e))
    
    def bulk_update(self, entities: List[TickerDirectory]) -> int:
        """
        Update multiple ticker directory entries in a single transaction.
        
        Args:
            entities: List of TickerDirectory entities to update
        
        Returns:
            Number of rows successfully updated
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        if not entities:
            return 0
        
        update_query = """
        UPDATE ticker_directory
        SET cik = %s, status = %s, last_updated_at = CURRENT_TIMESTAMP
        WHERE ticker = %s;
        """
        
        try:
            with self.db_manager.get_cursor_context() as cursor:
                data = [
                    (
                        td.cik,
                        td.status.value,
                        td.ticker
                    )
                    for td in entities
                ]
                cursor.executemany(update_query, data)
                rows_updated = cursor.rowcount
                self.logger.info(f"Successfully bulk updated {rows_updated} ticker directory entries")
                return rows_updated

        except Exception as e:
            raise DatabaseQueryError("bulk update ticker directory", str(e))
    
    def update_status(self, ticker: str, status: TickerDirectoryStatus) -> TickerDirectory:
        """
        Update the status of a ticker directory entry.
        
        Args:
            ticker: The ticker of the entry to update
            status: The new status
        
        Returns:
            Updated TickerDirectory
        
        Raises:
            TickerDirectoryNotFoundError: If ticker doesn't exist
            DatabaseQueryError: If database operation fails
        """
        # Check if the entry exists
        existing = self.get_by_ticker(ticker)
        if existing is None:
            raise TickerDirectoryNotFoundError("ticker", ticker)
        
        update_query = """
        UPDATE ticker_directory
        SET status = %s, last_updated_at = CURRENT_TIMESTAMP
        WHERE ticker = %s
        RETURNING cik, ticker, created_at, last_updated_at, status, id;
        """
        
        try:
            with self.db_manager.get_cursor_context() as cursor:
                cursor.execute(update_query, (status.value, ticker.upper()))
                row = cursor.fetchone()
                
                if row is None:
                    raise DatabaseQueryError("update ticker directory status", "No row returned after update")
                
                updated_entity = self._row_to_entity(row)
                self.logger.info(f"Successfully updated status for ticker {ticker} to {status.value}")
                return updated_entity

        except Exception as e:
            raise DatabaseQueryError("update ticker directory status", str(e))
    
    def bulk_update_status(self, tickers: List[str], status: TickerDirectoryStatus) -> int:
        """
        Update the status of multiple ticker directory entries in bulk.
        
        Args:
            tickers: List of tickers to update
            status: The new status to set for all tickers
        
        Returns:
            Number of rows successfully updated
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        if not tickers:
            return 0
        
        # Normalize tickers to uppercase
        normalized_tickers = [ticker.upper() for ticker in tickers]
        
        update_query = """
        UPDATE ticker_directory
        SET status = %s, last_updated_at = CURRENT_TIMESTAMP
        WHERE ticker = ANY(%s);
        """
        
        try:
            with self.db_manager.get_cursor_context() as cursor:
                cursor.execute(update_query, (status.value, normalized_tickers))
                rows_updated = cursor.rowcount
                self.logger.info(f"Successfully bulk updated {rows_updated} entries to status {status.value}")
                return rows_updated

        except Exception as e:
            raise DatabaseQueryError("bulk update ticker directory status", str(e))
    
    # ============================================================================
    # DELETE OPERATIONS
    # ============================================================================
    
    def delete(self, entity_id: int) -> bool:
        """
        Delete a ticker directory entry by ID (primary key).
        
        Args:
            entity_id: The ID of the entry to delete
        
        Returns:
            True if deletion was successful, False otherwise
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        delete_query = "DELETE FROM ticker_directory WHERE id = %s;"
        
        try:
            with self.db_manager.get_cursor_context() as cursor:
                cursor.execute(delete_query, (entity_id,))
                deleted = cursor.rowcount > 0
                
                if deleted:
                    self.logger.info(f"Successfully deleted ticker directory entry: ID {entity_id}")
                else:
                    self.logger.warning(f"No ticker directory entry found to delete: ID {entity_id}")
                
                return deleted

        except Exception as e:
            raise DatabaseQueryError("delete ticker directory", str(e))
    
    def bulk_delete(self, entity_ids: List[int]) -> int:
        """
        Delete multiple ticker directory entries in a single transaction.
        
        Args:
            entity_ids: List of IDs to delete
        
        Returns:
            Number of rows successfully deleted
        
        Raises:
            DatabaseQueryError: If database operation fails
        """
        if not entity_ids:
            return 0
        
        # Use ANY for bulk delete with array parameter
        delete_query = "DELETE FROM ticker_directory WHERE id = ANY(%s);"
        
        try:
            with self.db_manager.get_cursor_context() as cursor:
                cursor.execute(delete_query, (entity_ids,))
                rows_deleted = cursor.rowcount
                self.logger.info(f"Successfully bulk deleted {rows_deleted} ticker directory entries")
                return rows_deleted

        except Exception as e:
            raise DatabaseQueryError("bulk delete ticker directory", str(e))

    def bulk_delete_by_cik(self, ciks: List[int]) -> int:
        """
        Delete multiple ticker directory entries by CIK in a single transaction.

        Args:
            ciks: List of CIKs to delete ticker directory entries for

        Returns:
            Number of rows successfully deleted

        Raises:
            DatabaseQueryError: If database operation fails
        """
        if not ciks:
            return 0

        # Create placeholders for the IN clause
        placeholders = ','.join(['%s'] * len(ciks))
        delete_query = f"DELETE FROM ticker_directory WHERE cik IN ({placeholders});"

        try:
            with self.db_manager.get_cursor_context() as cursor:
                cursor.execute(delete_query, ciks)  # type: ignore[arg-type]
                rows_deleted = cursor.rowcount
                self.logger.info(f"Successfully bulk deleted {rows_deleted} ticker directory entries by CIK")
                return rows_deleted

        except Exception as e:
            raise DatabaseQueryError("bulk delete ticker directory by CIK", str(e))
    
    # ============================================================================
    # HELPER METHODS
    # ============================================================================
    
    def _row_to_entity(self, row: tuple[Any, ...]) -> TickerDirectory:
        """
        Convert a database row to a TickerDirectory entity.
        
        Args:
            row: Database row tuple (cik, ticker, created_at, last_updated_at, status, id)
        
        Returns:
            TickerDirectory entity
        """
        # Normalize DB enum (could be 'active' or 'ACTIVE') into our Enum
        raw_status = row[4]
        status_enum: TickerDirectoryStatus
        if isinstance(raw_status, str):
            try:
                # Try mapping from uppercase of the raw label (our Enum uses uppercase labels)
                status_enum = TickerDirectoryStatus(raw_status.upper())
            except ValueError:
                # As a last resort, try direct construction (this may raise)
                status_enum = TickerDirectoryStatus(raw_status)
        else:
            # If driver returned an enum-like object, coerce to string then to enum
            try:
                status_enum = TickerDirectoryStatus(str(raw_status))
            except Exception:
                status_enum = TickerDirectoryStatus.ACTIVE

        return TickerDirectory(
            ticker=row[1],
            cik=row[0],
            status=status_enum,
            id=row[5],
            created_at=row[2],
            last_updated_at=row[3]
        )
